---
    layout: post
    title: just algorithm
---

# algorithm 

## 1. 渐进符号的定义
- 上限大O的数学定义
    > 对于f(n) = O(g(n))，表示存在适当的常数c>0,n0>0，使得f(n) ≤ c·g(n)，对于所有的n≥n0
    > f(n)可以说是属于g(n)构成的函数集，可以定义O(g(n))为一个函数集O(g(n)) = { f(n)：存在c>0、n0>0，使得0≤f(n)≤cg(n)，其中n≥n0 }


## 2. 插入排序，归并排序

- insert sort:  两层循环将key插入排好序的array中，f(n)=n+(n-1)+(n-2)+...+1=Θ(n^2)

    ```java

     /**
     * This method implements the Generic Insertion Sort
     *
     * @param array The array to be sorted
     * @param last The count of total number of elements in array
     * Sorts the array in increasing order
     **/

    public static <T extends Comparable<T>> void IS(T array[], int last) {
        T key;
        for (int j=1;j<last;j++) {

            // Picking up the key(Card)
            key = array[j];
            int i = j-1;
            while (i>=0 && key.compareTo(array[i]) < 0) {
                array[i+1] = array[i];
                i--;
            }
            // Placing the key (Card) at its correct position in the sorted subarray
            array[i+1] = key;
        }
    }

    
    ```


 - merge sort:递归地合并两个排序好的array，f(n)=2f(n/2)+n=Θ(nlgn)

    ```java 
     /**
     * This method implements the Generic Merge Sort
     *
     * @param arr The array to be sorted
     * @param temp The copy of the actual array
     * @param left The first index of the array
     * @param right The last index of the array
     * Recursively sorts the array in increasing order
     **/

    public static <T extends Comparable<T>> void MS(T[] arr, T[] temp, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            MS(arr, temp, left, mid);
            MS(arr,  temp,mid + 1, right);
            merge(arr, temp, left, mid, right);
        }

    }
    
    ```

    ```java 
    /**
     * This method implements the merge step of the merge sort
     *
     * @param arr The array to be sorted
     * @param temp The copy of the actual array
     * @param left The first index of the array
     * @param mid The middle index of the array
     * @param right The last index of the array
     * merges two parts of an array in increasing order
     **/

    public static <T extends Comparable<T>> void merge(T[] arr, T[] temp, int left, int mid, int right) {
        for (int i=left;i<=right;i++) {
            temp[i] = arr[i];
        }

        int i= left;
        int j = mid + 1;
        int k = left;

        while (i<=mid && j<=right) {
            if (temp[i].compareTo(temp[j]) <= 0) {
                arr[k] = temp[i];
                i++;
            }
            else {
                arr[k] = temp[j];
                j++;
            }
            k++;
        }

        while (i <= mid) {
            arr[k] = temp[i];
            i++;
            k++;
        }
    }
    
    ```

## 3. 递归式的解法：
-  合理的猜结果：用替换法证明   
-  递归树：需要加上所以树节点的值，主要有两个因素影响，树高h，页节点数量leafs  

    ![retree](/images/retree.png)

- 主定理：T(n) = aT(n/b)+f(n)
    ![mainΜethod](/images/Mastermethod.png)

* 上面三种方法可以互相映证

## 4. 分治法：  
在每一层递归上都有三个步骤：   

- 分解：将原问题分解为若干个规模较小，相对独立，与原问题形式相同的子问题
- 解决：若子问题规模较小且易于解决时，则直接解。否则，递归地解决各子问题。
- 合并：将各子问题的解合并为原问题的解。

    上面的merge sort 就是一个经典的例子
    


## 5. 快速排序


## 6. 计数排序及基数排序
-  像快排这类基于比较的排序，可以以决策树的形式证明，
