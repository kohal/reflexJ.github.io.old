---
    layout: post
    title: just algorithm
---

# algorithm 

## 1. 渐进符号的定义
- 上限大O的数学定义
    > 对于f(n) = O(g(n))，表示存在适当的常数c>0,n0>0，使得f(n) ≤ c·g(n)，对于所有的n≥n0
    > f(n)可以说是属于g(n)构成的函数集，可以定义O(g(n))为一个函数集O(g(n)) = { f(n)：存在c>0、n0>0，使得0≤f(n)≤cg(n)，其中n≥n0 }


## 2. 插入排序，归并排序

- insert sort:  两层循环将key插入排好序的array中，f(n)=n+(n-1)+(n-2)+...+1=Θ(n^2)

    ```java

     /**
     * This method implements the Generic Insertion Sort
     *
     * @param array The array to be sorted
     * @param last The count of total number of elements in array
     * Sorts the array in increasing order
     **/

    public static <T extends Comparable<T>> void IS(T array[], int last) {
        T key;
        for (int j=1;j<last;j++) {

            // Picking up the key(Card)
            key = array[j];
            int i = j-1;
            while (i>=0 && key.compareTo(array[i]) < 0) {
                array[i+1] = array[i];
                i--;
            }
            // Placing the key (Card) at its correct position in the sorted subarray
            array[i+1] = key;
        }
    }

    
    ```


 - merge sort:递归地合并两个排序好的array，f(n)=2f(n/2)+n=Θ(nlgn)

    ```java 
     /**
     * This method implements the Generic Merge Sort
     *
     * @param arr The array to be sorted
     * @param temp The copy of the actual array
     * @param left The first index of the array
     * @param right The last index of the array
     * Recursively sorts the array in increasing order
     **/

    public static <T extends Comparable<T>> void MS(T[] arr, T[] temp, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            MS(arr, temp, left, mid);
            MS(arr,  temp,mid + 1, right);
            merge(arr, temp, left, mid, right);
        }

    }
    
    ```

    ```java 
    /**
     * This method implements the merge step of the merge sort
     *
     * @param arr The array to be sorted
     * @param temp The copy of the actual array
     * @param left The first index of the array
     * @param mid The middle index of the array
     * @param right The last index of the array
     * merges two parts of an array in increasing order
     **/

    public static <T extends Comparable<T>> void merge(T[] arr, T[] temp, int left, int mid, int right) {
        for (int i=left;i<=right;i++) {
            temp[i] = arr[i];
        }

        int i= left;
        int j = mid + 1;
        int k = left;

        while (i<=mid && j<=right) {
            if (temp[i].compareTo(temp[j]) <= 0) {
                arr[k] = temp[i];
                i++;
            }
            else {
                arr[k] = temp[j];
                j++;
            }
            k++;
        }

        while (i <= mid) {
            arr[k] = temp[i];
            i++;
            k++;
        }
    }
    
    ```

## 3. 递归式的解法：
-  合理的猜结果：用替换法证明   
-  递归树：需要加上所以树节点的值，主要有两个因素影响，树高h，页节点数量leafs  

    ![retree](/images/retree.png)

- 主定理：T(n) = aT(n/b)+f(n)
    ![mainΜethod](/images/Mastermethod.png)

* 上面三种方法可以互相映证

## 4. 分治法：  
在每一层递归上都有三个步骤：   

- 分解：将原问题分解为若干个规模较小，相对独立，与原问题形式相同的子问题
- 解决：若子问题规模较小且易于解决时，则直接解。否则，递归地解决各子问题。
- 合并：将各子问题的解合并为原问题的解。

    上面的merge sort 就是一个经典的例子
    


## 5. 快速排序
- 选择一个pivot,
```java
 /**
     * This method implements the Generic Quick Sort
     *
     * @param array The array to be sorted
     * @param start The first index of an array
     * @param end The last index of an array
     * Sorts the array in increasing order
     **/

    public static <T extends Comparable<T>> void QS(T array[], int start, int end) {
        if (start < end) {
            int PIndex = partition(array, start, end);
            QS(array, start, PIndex - 1);
            QS(array, PIndex + 1, end);
        }
    }

    /**
     * This method finds the partition index for an array
     *
     * @param array The array to be sorted
     * @param start The first index of an array
     * @param end The last index of an array
     * Finds the partition index of an array
     **/

    public static <T extends Comparable<T>> int partition(T array[], int start, int end) {
        T pivot = array[end];
        int PIndex = start;
        for (int i=start;i<end;i++) {
            if (array[i].compareTo(pivot) <= 0) {
                swap(array, i, PIndex);
                PIndex++;
            }
        }
        swap(array, PIndex, end);
        return PIndex;
    }

```

```python

def quick_sort(arr, simulation=False):
    """ Quick sort
        Complexity: best O(n log(n)) avg O(n log(n)), worst O(N^2)
    """
    
    iteration = 0
    if simulation:
        print("iteration",iteration,":",*arr)
    arr, _ = quick_sort_recur(arr, 0, len(arr) - 1, iteration, simulation)
    return arr

def quick_sort_recur(arr, first, last, iteration, simulation):
    if first < last:
        pos = partition(arr, first, last)
        # Start our two recursive calls
        if simulation:
            iteration = iteration + 1
            print("iteration",iteration,":",*arr)
            
        _, iteration = quick_sort_recur(arr, first, pos - 1, iteration, simulation)
        _, iteration = quick_sort_recur(arr, pos + 1, last, iteration, simulation)

    return arr, iteration

def partition(arr, first, last):
    wall = first
    for pos in range(first, last):
        if arr[pos] < arr[last]:  # last is the pivot
            arr[pos], arr[wall] = arr[wall], arr[pos]
            wall += 1
    arr[wall], arr[last] = arr[last], arr[wall]
    return wall

```




## 6. 计数排序及基数排序
-  像快排这类基于比较的排序，可以以决策树的形式证明   
    * 每个节点是比较，叶子节点是所以可能的结果，n的阶乘，满二叉树的高度为 nlgn,这就是比较排序最好的时间复杂度。
    * 决策树  
    一个决策树包含三种类型的节点：
       - 决策节点：通常用矩形框来表示
       - 机会节点：通常用圆圈来表示
       - 终结点：通常用三角形来表示
        ![decision_tree](/images/Decision-Tree.png)

- 计数排序：当输入的元素是n个 0～k的整数时，T(n)=Θ(n+k)，是稳定的线性排序算法

- 基数排序：按位分隔，每一部分可以采用计数排序,可以用归纳法证明.基数排序的T(n)=Θ(n*k),k是数字位数


## 7. 顺序统计和中值
- 有一系列的元素n在数组中（无序），希望找到第k小的数  
    * 随机分治算法
    ```c
    if p=q then 
    return A[p]
    r = random-select(A, p, q)       | 快速排序的方法
    k = r-p+1                        | 划分元素的序号
    if i=k then return A[r]
    if i<k then 
        return random-select(A, p, r-1, i)
    if i>k then
        return ramdom-select(A, r-1, q, i)

    ```
    最差情况，T(n)=T(n-1)+c*n;

    * 为了消除理论上的最差情况
        ![partition](/images/privot.png)

## 8. 哈希表


