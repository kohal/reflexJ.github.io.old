###java线程池的一些使用

```java


Future future = threadPool.submit(new Callable() {
                        @Override
                        public Object call() throws Exception {
                            doSomething();
                            return Object;
                        }
                    });
                    resultHolder.add(future);
                }


                for (int i = 0; i < resultHolder.size(); i++) {
                    Future<Object> future = resultHolder.get(i);
                    if (future.isDone()) {
                         Object object= future.get();
                        resultHolder.remove(i);
                        i--;
                    }
                    if (i == resultHolder.size() - 1) i = -1;

                }

```

```java
ExecutorCompletionService executorCompletionService = new ExecutorCompletionService(threadPool);

```

* 线程池的执行图

    ![threadPool](/images/threadPool.png)

1. 如果当前运行的线程少于corePoolSize直接创建新线程来执行任务，需要获取全局锁。
2. 如果运行的线程等于或多余corePoolSize则将任务加入BlockingQueue。
3. 如果由于队列已满，无法将任务加到BlockingQueue，则创建新的线程来处任务，需要获取全局锁。
4. 如果创建新线程将操作maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。
